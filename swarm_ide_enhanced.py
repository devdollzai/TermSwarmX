#!/usr/bin/env python3
"""
AI Swarm IDE - Enhanced Sharp CLI Interface
Professional, frictionless AI development terminal with Gemini-inspired UX
"""

import multiprocessing as mp
import queue
import time
import sys
import json
import sqlite3
import datetime
import ollama
import os
import importlib.util
from concurrent.futures import ThreadPoolExecutor
from textual.app import App, ComposeResult
from textual.widgets import DirectoryTree, Log, Input, Header, Footer, Static, TextArea
from textual.containers import Horizontal, Vertical
from textual.reactive import reactive
from textual.binding import Binding
from prompt_toolkit import PromptSession
from prompt_toolkit.completion import WordCompleter
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.lexers import PygmentsLexer
from pygments.lexers.python import PythonLexer

# Setup SQLite for command history
DB_FILE = "atelier_memory.db"  # Renamed as per branding directives

def init_db():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS history 
                      (id INTEGER PRIMARY KEY, timestamp TEXT, agent TEXT, task TEXT, result TEXT)''')
    conn.commit()
    conn.close()

init_db()

def log_to_db(agent, task, result):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    timestamp = datetime.datetime.now().isoformat()
    cursor.execute("INSERT INTO history (timestamp, agent, task, result) VALUES (?, ?, ?, ?)", 
                   (timestamp, agent, task, result))
    conn.commit()
    conn.close()

# Structured message format
def create_message(content, meta=None):
    return json.dumps({"content": content, "meta": meta or {}})

def parse_message(msg):
    return json.loads(msg)

# Code Generation Agent with async Ollama
async def code_gen_agent_async(prompt):
    try:
        response = await ollama.async_generate(model="mistral", prompt=prompt)
        return response['response'].strip()
    except Exception as e:
        return f"Error: {str(e)}"

def code_gen_agent(input_queue, output_queue):
    executor = ThreadPoolExecutor(max_workers=1)  # For async calls in sync context
    while True:
        try:
            raw_task = input_queue.get(timeout=1)
            if raw_task == "STOP":
                break
            task = parse_message(raw_task)
            cmd_type = task['meta'].get('type', '')
            desc = task['content']
            
            if cmd_type == "function":
                prompt = f"Generate a Python function for '{desc}'. Include error handling and type hints. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            elif cmd_type == "class":
                prompt = f"Generate a Python class for '{desc}' with relevant methods. Include error handling and type hints. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            else:
                prompt = f"Generate Python code for '{desc}'. Include error handling and type hints where applicable. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            
            try:
                # Use synchronous Ollama for now (async version may not be available)
                response = ollama.generate(model="mistral", prompt=prompt)
                result = response['response'].strip()
                meta = {"status": "success", "timestamp": time.time()}
            except Exception as e:
                result = "Error: Failed to generate code (Ollama unavailable)"
                meta = {"status": "error", "error": str(e)}
            
            output_queue.put(create_message(result, meta))
            log_to_db("code_gen", desc, result)
        except queue.Empty:
            time.sleep(0.1)
        except Exception as e:
            meta = {"status": "error", "error": str(e)}
            output_queue.put(create_message("Error in code generation", meta))
    executor.shutdown()

# Debug Agent with Ollama
def debug_agent(input_queue, output_queue):
    while True:
        try:
            raw_task = input_queue.get(timeout=1)
            if raw_task == "STOP":
                break
            task = parse_message(raw_task)
            cmd_type = task['meta'].get('type', '')
            code = task['content']
            
            if cmd_type == "syntax":
                prompt = f"Analyze this Python code for syntax errors: ```\n{code}\n```. Return only the analysis, no code or explanations. // Generated by DevDollz: Atelier Edition"
            elif cmd_type == "logic":
                prompt = f"Analyze this Python code for logical errors and potential issues (e.g., edge cases, performance): ```\n{code}\n```. Return only the analysis, no code or explanations. // Generated by DevDollz: Atelier Edition"
            else:
                prompt = f"Debug this Python code for any issues: ```\n{code}\n```. Return only the debug analysis, no code or explanations. // Generated by DevDollz: Atelier Edition"
            
            try:
                response = ollama.generate(model="mistral", prompt=prompt)
                result = response['response'].strip()
                meta = {"status": "success", "timestamp": time.time()}
            except Exception as e:
                result = "Error: Failed to debug code (Ollama unavailable)"
                meta = {"status": "error", "error": str(e)}
            
            output_queue.put(create_message(result, meta))
            log_to_db("debug", code, result)
        except queue.Empty:
            time.sleep(0.1)
        except Exception as e:
            meta = {"status": "error", "error": str(e)}
            output_queue.put(create_message("Error in debug", meta))

# Voice Recognition Agent
def voice_agent(input_queue, output_queue):
    try:
        import speech_recognition as sr
    except ImportError:
        output_queue.put(create_message("Dependencies missing. Run: pip install SpeechRecognition PyAudio", {"status": "error"}))
        return

    r = sr.Recognizer()
    while True:
        try:
            raw_task = input_queue.get(timeout=1)
            if raw_task == "STOP":
                break
            output_queue.put(create_message("Listening...", {"status": "info", "source": "voice"}))
            with sr.Microphone() as source:
                r.adjust_for_ambient_noise(source, duration=0.5)
                try:
                    audio = r.listen(source, timeout=5, phrase_time_limit=5)
                    text = r.recognize_google(audio)
                    output_queue.put(create_message(text, {"status": "success", "source": "voice"}))
                except sr.WaitTimeoutError:
                    output_queue.put(create_message("No audio detected within 5 seconds", {"status": "error", "source": "voice"}))
                except sr.UnknownValueError:
                    output_queue.put(create_message("Could not understand audio", {"status": "error", "source": "voice"}))
                except sr.RequestError as e:
                    output_queue.put(create_message(f"Speech service error: {e}", {"status": "error", "source": "voice"}))
        except queue.Empty:
            time.sleep(0.1)
        except Exception as e:
            output_queue.put(create_message(f"Voice agent error: {e}", {"status": "error", "source": "voice"}))

# Central Orchestrator with Plugin Support
class Orchestrator:
    def __init__(self):
        # Core AI Agents
        self.agents = {
            "code_gen": self.create_agent(code_gen_agent),
            "debug": self.create_agent(debug_agent),
        }
        # Voice Agent
        self.voice_input = mp.Queue()
        self.voice_output = mp.Queue()
        self.voice_proc = mp.Process(target=voice_agent, args=(self.voice_input, self.voice_output), daemon=True)
        self.voice_proc.start()

    def create_agent(self, target_func):
        input_q = mp.Queue()
        output_q = mp.Queue()
        proc = mp.Process(target=target_func, args=(input_q, output_q))
        proc.start()
        return {"input_q": input_q, "output_q": output_q, "proc": proc}

    def load_plugin(self, file_path):
        plugin_name = os.path.splitext(os.path.basename(file_path))[0]
        if plugin_name in self.agents:
            return {"content": f"Plugin '{plugin_name}' already loaded.", "meta": {"status": "error"}}

        try:
            spec = importlib.util.spec_from_file_location(plugin_name, file_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            if not hasattr(module, 'plugin_agent'):
                return {"content": f"Plugin must have a 'plugin_agent' function.", "meta": {"status": "error"}}

            self.agents[plugin_name] = self.create_agent(module.plugin_agent)
            return {"content": f"Plugin '{plugin_name}' loaded successfully.", "meta": {"status": "success"}}
        except Exception as e:
            return {"content": f"Failed to load plugin: {e}", "meta": {"status": "error"}}

    def route_task(self, agent_name, cmd_type, task_content):
        if agent_name not in self.agents:
            return {"content": f"Unknown agent '{agent_name}'.", "meta": {"status": "error"}}
        
        agent = self.agents[agent_name]
        task_msg = create_message(task_content, {"type": cmd_type or "custom"})
        agent["input_q"].put(task_msg)
        return {"content": f"Routed to '{agent_name}'.", "meta": {"status": "success"}}

    def get_results(self):
        results = []
        # AI and Plugin agents
        for agent_name, agent_data in self.agents.items():
            q = agent_data["output_q"]
            try:
                while not q.empty():
                    raw_res = q.get()
                    res = parse_message(raw_res)
                    res['meta']['source'] = agent_name
                    results.append(res)
            except queue.Empty:
                pass
        # Voice agent
        try:
            while not self.voice_output.empty():
                raw_res = self.voice_output.get()
                res = parse_message(raw_res)
                res['meta']['source'] = "voice"
                results.append(res)
        except queue.Empty:
            pass
        return results

    def start_voice_listening(self):
        self.voice_input.put("START")

    def shutdown(self):
        for agent in self.agents.values():
            agent["input_q"].put("STOP")
            agent["proc"].join()
        self.voice_input.put("STOP")
        self.voice_proc.terminate()

# DevDollz ASCII Logo
DEV_DOLLZ_LOGO = """
██████╗ ██╗██╗   ██╗██╗  ██╗ ██████╗ ██╗     ██╗     ███████╗
██╔══██╗██║██║   ██║██║  ██║██╔═══██╗██║     ██║     ╚══███╔╝
██║  ██║██║██║   ██║██║  ██║██║   ██║██║     ██║       ███╔╝ 
██║  ██║██║██║   ██║██║  ██║██║   ██║██║     ██║      ███╔╝  
██████╔╝██║╚██████╔╝╚██████╔╝╚██████╔╝███████╗███████╗███████╗
╚═════╝ ╚═╝ ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝╚══════╝╚══════╝
"""

# Textual TUI App with DevDollz: Atelier Edition Theme
class SwarmIDEApp(App):
    BINDINGS = [
        Binding("ctrl+d", "debug_code", "Debug Code", show=True),
        Binding("ctrl+s", "save_file", "Save File", show=True),
        Binding("ctrl+v", "listen_voice", "Voice Command", show=True),
    ]

    CSS = """
    /* DevDollz: Atelier Edition Enhanced Theme by Alexis Adams */
    
    $background: #1A1A1B;
    $primary: #D944D4;
    $panel: #2C2C2E;
    $success: #D944D4;
    $error: #E06C75;
    $text: #EAEAEB;
    $muted: #8A8A8E;

    Screen {
        background: $background;
        color: $text;
    }

    /* === HEADER & FOOTER === */
    Header {
        display: none; /* Hide default header */
    }
    #logo {
        color: $muted;
        height: auto;
        padding: 1 0;
    }
    Footer {
        background: $background;
        color: $muted;
    }

    /* === PANELS & CONTAINERS === */
    Horizontal, Vertical {
        background: $background;
    }

    DirectoryTree, Log, TextArea {
        background: $panel;
        border: solid $panel;
        padding: 1 2;
    }

    Vertical {
        padding: 0;
        border: none;
    }

    /* === COMMAND INPUT === */
    Input {
        background: $background;
        border: solid $muted;
        padding: 0 1;
        color: $text;
        height: 1;
        margin-top: 1;
    }

    Input:focus {
        border: solid $primary;
    }

    Input > .input--placeholder {
        color: $muted;
        text-style: none;
    }

    /* === CODE EDITOR === */
    TextArea {
        background: $panel;
        border: solid $muted;
        color: $text;
    }

    TextArea:focus {
        border: solid $primary;
    }

    /* === FILE & DIRECTORY TREE === */
    DirectoryTree > .directory-tree--file {
        color: $text;
    }
    DirectoryTree > .directory-tree--folder {
        color: $text;
    }
    DirectoryTree > .directory-tree--selected {
        background: $primary;
        color: $background;
        text-style: bold;
    }

    /* === RESULTS LOG === */
    Log {
        color: $text;
        height: 10;
        margin-top: 1;
    }

    /* === SCROLLBARS === */
    ScrollBar {
        background: $panel;
        width: 1;
    }
    ScrollBar > .scrollbar-thumb {
        background: $muted;
    }
    """

    def __init__(self):
        super().__init__()
        self.orchestrator = Orchestrator()
        self.active_file_path = None
        self.project_root = os.path.abspath(".")

    def compose(self) -> ComposeResult:
        yield Static(DEV_DOLLZ_LOGO, id="logo")
        yield Horizontal(
            DirectoryTree(self.project_root, id="file-tree"),
            Vertical(
                TextArea(id="code-editor", language="python"),
                Log(id="results"),
                Input(placeholder="> Enter command...", id="command-input"),
                id="main-panel"
            )
        )
        yield Footer()

    def on_mount(self) -> None:
        footer = self.query_one(Footer)
        footer.text = "Built for power users - DevDollz: Atelier Edition"
        self.query_one("#command-input").focus()
        self.set_interval(0.1, self.check_results)
        text_log = self.query_one("#results", Log)
        text_log.write("Welcome to the Atelier. | DevDollz by Alexis Adams")
        text_log.write("Enhanced features: Voice commands (Ctrl+V), Plugin system, Code editor")

    def check_results(self) -> None:
        results = self.orchestrator.get_results()
        text_log = self.query_one("#results", Log)
        for res in results:
            status = res['meta'].get('status', 'unknown')
            source = res['meta'].get('source', 'ai')
            
            if source == 'voice':
                if status == 'success':
                    text_log.write(f"[»] Recognized: \"{res['content']}\"")
                    self.process_command(res['content'])
                elif status == 'info':
                    text_log.write(f"[»] {res['content']}")
                else:
                    text_log.write(f"[x] {res['content']}")
            else:
                if status == "success":
                    text_log.write(f"[◆] [{source}] {res['content']}")
                else:
                    text_log.write(f"[x] [{source}] {res['content']}")

    def on_input_submitted(self, event: Input.Submitted) -> None:
        self.process_command(event.value)
        event.input.value = ""

    def process_command(self, command: str) -> None:
        text_log = self.query_one("#results", Log)
        command = command.strip()
        
        protocol_text = "Atelier Protocol:\n  generate [function|class|code] <desc>\n  debug [syntax|logic|code] <desc>\n  history [limit]\n  plugin load <path>"

        if command.lower() in ['quit', 'exit']:
            self.exit()
            return
        if command.lower() == 'help':
            text_log.write(protocol_text)
            return
        
        if command.startswith("history"):
            self.action_show_history(command)
            return

        if command.startswith("plugin load"):
            parts = command.split(maxsplit=2)
            if len(parts) < 3:
                text_log.write("[x] Usage: plugin load <path_to_file.py>")
                return
            
            file_path = parts[2]
            if not os.path.abspath(file_path).startswith(self.project_root):
                text_log.write(f"[x] Access Denied: Plugins must be loaded from within the project directory.")
                return

            result = self.orchestrator.load_plugin(file_path)
            status = result['meta'].get('status', 'unknown')
            if status == "success":
                text_log.write(f"[◆] {result['content']}")
            else:
                text_log.write(f"[x] {result['content']}")
            return

        # Normalize spoken commands
        command = (command.replace("create function", "generate function")
                          .replace("create class", "generate class")
                          .replace("create code", "generate code")
                          .replace("check syntax", "debug syntax")
                          .replace("check logic", "debug logic"))

        parts = command.split(maxsplit=2)
        if len(parts) < 1:
            text_log.write(f"Access Denied. Please verify command syntax.\n{protocol_text}")
            return

        agent_name = parts[0]
        if len(parts) == 1:
            task_content = ""
        else:
            cmd_type = parts[1]
            task_content = parts[2] if len(parts) > 2 else ""

        if agent_name in self.orchestrator.agents:
            text_log.write(f"[»] Routing to plugin '{agent_name}'...")
            self.orchestrator.route_task(agent_name, cmd_type, task_content)
            return

        if agent_name not in ["generate", "debug"]:
            text_log.write(f"Access Denied. Unknown command or plugin.\n{protocol_text}")
            return

        agent_name = "code_gen" if agent_name == "generate" else "debug"
        text_log.write("[»] Crafting response...")
        self.orchestrator.route_task(agent_name, cmd_type, task_content)

    def on_directory_tree_file_selected(self, event: DirectoryTree.FileSelected) -> None:
        text_log = self.query_one("#results", Log)
        code_editor = self.query_one("#code-editor", TextArea)
        
        file_path = event.path
        if not os.path.abspath(file_path).startswith(self.project_root):
            text_log.write(f"[x] Access Denied: Cannot access files outside the project directory.")
            return

        try:
            with open(file_path, "r") as file:
                code_editor.text = file.read()
            self.active_file_path = file_path
            text_log.write(f"[»] Loaded file: {os.path.basename(file_path)}")
        except Exception as e:
            text_log.write(f"[x] Error loading file: {e}")
            self.active_file_path = None

    def action_debug_code(self) -> None:
        code_editor = self.query_one("#code-editor", TextArea)
        text_log = self.query_one("#results", Log)
        code = code_editor.text.strip()
        if not code:
            text_log.write("[x] No code in editor to debug.")
            return
        
        cmd_type = "code"
        text_log.write("[»] Debugging code from editor...")
        self.orchestrator.route_task("debug", cmd_type, code)

    def action_save_file(self) -> None:
        text_log = self.query_one("#results", Log)
        if self.active_file_path is None:
            text_log.write("[x] No active file selected. Load a file first.")
            return

        if not os.path.abspath(self.active_file_path).startswith(self.project_root):
            text_log.write(f"[x] Access Denied: Cannot save files outside the project directory.")
            return

        code_editor = self.query_one("#code-editor", TextArea)
        try:
            with open(self.active_file_path, "w") as file:
                file.write(code_editor.text)
            text_log.write(f"[◆] Saved file: {os.path.basename(self.active_file_path)}")
        except Exception as e:
            text_log.write(f"[x] Error saving file: {e}")

    def action_show_history(self, command: str) -> None:
        text_log = self.query_one("#results", Log)
        parts = command.split()
        limit = 10
        if len(parts) > 1 and parts[1].isdigit():
            limit = int(parts[1])
        
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("SELECT timestamp, agent, task FROM history ORDER BY id DESC LIMIT ?", (limit,))
            records = cursor.fetchall()
            conn.close()

            if not records:
                text_log.write("[»] No history found.")
                return
            
            history_text = "[»] Command History:\n"
            for rec in records:
                ts, agent, task = rec
                short_task = (task[:40] + '...') if len(task) > 40 else task
                history_text += f"  - {ts[:19]} [{agent}]: {short_task}\n"
            text_log.write(history_text)
        except Exception as e:
            text_log.write(f"[x] Error fetching history: {e}")

    def action_listen_voice(self) -> None:
        self.orchestrator.start_voice_listening()

    def on_key(self, event):
        if event.key == "question_mark":
            text_log = self.query_one("#results", Log)
            text_log.write("Atelier Protocol:\n  generate [function|class|code] <desc>\n  debug [syntax|logic|code] <desc>\n  history [limit]\n  plugin load <path>")
        elif event.key == "tab":
            self.screen.focus_next()

    def on_unmount(self):
        self.orchestrator.shutdown()

# CLI Fallback (if Textual is unavailable)
def create_cli():
    bindings = KeyBindings()
    @bindings.add('?')
    def _(event):
        event.app.exit(result='help')

    completer = WordCompleter(['generate function ', 'generate class ', 'generate code ', 
                               'debug syntax ', 'debug logic ', 'debug code ', 'history ', 'plugin load '], ignore_case=True)
    session = PromptSession('> ', 
                           completer=completer, 
                           lexer=PygmentsLexer(PythonLexer),
                           key_bindings=bindings)
    return session

def print_usage():
    print("Access Denied. Please verify command syntax.")
    print("Atelier Protocol:")
    print("  generate [function|class|code] <desc>")
    print("  debug [syntax|logic|code] <desc>")
    print("  history [limit]")
    print("  plugin load <path>")
    print("Note: Voice commands are TUI-only (Ctrl+V).")

def query_history_cli(command: str):
    parts = command.split()
    limit = 10
    if len(parts) > 1 and parts[1].isdigit():
        limit = int(parts[1])
    
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("SELECT timestamp, agent, task FROM history ORDER BY id DESC LIMIT ?", (limit,))
        records = cursor.fetchall()
        conn.close()

        if not records:
            print("[»] No history found.")
            return
        
        print("[»] Command History:")
        for rec in records:
            ts, agent, task = rec
            short_task = (task[:50] + '...') if len(task) > 50 else task
            print(f"  - {ts[:19]} [{agent}]: {short_task}")
    except Exception as e:
        print(f"[x] Error fetching history: {e}")

# Main entry point
if __name__ == "__main__":
    try:
        SwarmIDEApp().run()
    except Exception as e:
        print(f"TUI failed to load ({e}). Falling back to CLI.")
        orch = Orchestrator()
        try:
            session = create_cli()
            while True:
                try:
                    command = session.prompt()
                    command = command.strip()
                    if command.lower() in ['quit', 'exit']:
                        break
                    if command.lower() == 'help':
                        print_usage()
                        continue
                    
                    if command.startswith("history"):
                        query_history_cli(command)
                        continue

                    if command.startswith("plugin load"):
                        parts = command.split(maxsplit=2)
                        if len(parts) < 3:
                            print("[x] Usage: plugin load <path_to_file.py>")
                            continue
                        
                        file_path = parts[2]
                        result = orch.load_plugin(file_path)
                        status = result['meta'].get('status', 'unknown')
                        if status == "success":
                            print(f"[◆] {result['content']}")
                        else:
                            print(f"[x] {result['content']}")
                        continue

                    # Normalize CLI commands
                    command = (command.replace("create function", "generate function")
                                      .replace("create class", "generate class")
                                      .replace("create code", "generate code")
                                      .replace("check syntax", "debug syntax")
                                      .replace("check logic", "debug logic"))

                    parts = command.split(maxsplit=2)
                    if len(parts) < 1:
                        print_usage()
                        continue

                    agent_name = parts[0]
                    if len(parts) == 1:
                        task_content = ""
                    else:
                        cmd_type = parts[1]
                        task_content = parts[2] if len(parts) > 2 else ""

                    if agent_name in orch.agents:
                        print(f"[»] Routing to plugin '{agent_name}'...")
                        orch.route_task(agent_name, cmd_type, task_content)
                    elif agent_name in ["generate", "debug"]:
                        agent_name = "code_gen" if agent_name == "generate" else "debug"
                        print("[»] Crafting response...")
                        orch.route_task(agent_name, cmd_type, task_content)
                    else:
                        print_usage()
                        continue

                    time.sleep(0.1)
                    results = orch.get_results()
                    for res in results:
                        status = res['meta'].get('status', 'unknown')
                        source = res['meta'].get('source', 'ai')
                        if status == "success":
                            print(f"[◆] [{source}] {res['content']}")
                        else:
                            print(f"[x] [{source}] {res['content']}")

                except KeyboardInterrupt:
                    break
                except Exception as e:
                    print(f"[x] Error: {str(e)}")
                    print_usage()
        finally:
            orch.shutdown()
            print("Shutdown complete.")
