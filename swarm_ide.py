#!/usr/bin/env python3
"""
DevDollz: Atelier Edition - Professional AI Development Terminal
Built for power users who demand excellence in their development environment.

Features:
- AI-powered code generation and debugging with true async Ollama calls
- Pylint static analysis integration for comprehensive code quality
- Voice command integration
- Plugin system for extensibility
- Cross-platform compatibility
- Professional "Onyx & Orchid" theme

Author: Alexis Adams
Brand: DevDollz: Atelier Edition
"""

import asyncio
import multiprocessing as mp
import queue
import time
import sys 
import json
import sqlite3
import datetime
import ollama
import os
import importlib.util
from concurrent.futures import ThreadPoolExecutor
from io import StringIO
from textual.app import App, ComposeResult
from textual.widgets import DirectoryTree, Log, Input, Header, Footer, Static, TextArea
from textual.containers import Horizontal, Vertical
from textual.binding import Binding
import numpy as np
from collections import defaultdict
import threading
import time
from datetime import datetime, timedelta

# Import local modules
from config import PRECOGNITION_CONFIG, AI_CONFIG, SYSTEM_CONFIG
from precognitive_ai import precognitive_ai

# Setup SQLite for command history
DB_FILE = SYSTEM_CONFIG["db_file"]  # Use config value

def init_db():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS history 
                      (id INTEGER PRIMARY KEY, timestamp TEXT, agent TEXT, task TEXT, result TEXT)''')
    conn.commit()
    conn.close()

init_db()

def log_to_db(agent, task, result):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    timestamp = datetime.datetime.now().isoformat()
    cursor.execute("INSERT INTO history (timestamp, agent, task, result) VALUES (?, ?, ?, ?)", 
                   (timestamp, agent, task, f"{result} // DevDollz: Atelier Edition"))
    conn.commit()
    conn.close()

# Structured message format
def create_message(content, meta=None):
    return json.dumps({"content": content, "meta": meta or {}})

def parse_message(msg):
    return json.loads(msg)

# Pylint wrapper for static analysis
def run_pylint(code):
    """Run pylint static analysis on Python code"""
    try:
        import pylint.lint
        import pylint.reporters.text
        
        # Create a temporary file-like object for pylint
        output = StringIO()
        reporter = pylint.reporters.text.TextReporter(output)
        
        # Configure pylint to be less verbose and focus on important issues
        args = [
            '--from-stdin',
            '--disable=C,R',  # Disable convention and refactor warnings for cleaner output
            '--msg-template={msg_id}:{line}:{column}: {msg}',
            '--reports=no',   # No summary report
            '--score=no'      # No score output
        ]
        
        # Run pylint
        pylint.lint.Run(args, reporter=reporter, exit=False, do_exit=False)
        
        # Write the code to pylint's input
        reporter.output_stream.write(code)
        reporter.output_stream.seek(0)
        
        # Get the output and filter it
        output.seek(0)
        lines = output.getvalue().splitlines()
        
        # Filter out empty lines and pylint header info
        issues = [line.strip() for line in lines if line.strip() and not line.startswith('***')]
        
        if not issues:
            return "No issues found."
        
        # Limit to first 5 issues to avoid overwhelming output
        limited_issues = issues[:5]
        if len(issues) > 5:
            limited_issues.append(f"... and {len(issues) - 5} more issues")
        
        return "; ".join(limited_issues)
        
    except ImportError:
        return "Pylint not installed. Run: pip install pylint"
    except Exception as e:
        return f"Pylint error: {str(e)}"

# ASYNC Agent Definitions - True non-blocking Ollama calls
async def code_gen_agent(input_queue: asyncio.Queue, output_queue: asyncio.Queue):
    """Async code generation agent with non-blocking Ollama calls"""
    while True:
        try:
            raw_task = await input_queue.get()
            if raw_task is None:  # Sentinel value to stop agent
                break
                
            task = parse_message(raw_task)
            cmd_type = task['meta'].get('type', '')
            desc = task['content']
            
            if cmd_type == "function":
                prompt = f"Generate a Python function for '{desc}'. Include error handling and type hints. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            elif cmd_type == "class":
                prompt = f"Generate a Python class for '{desc}' with relevant methods. Include error handling and type hints. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            else:
                prompt = f"Generate Python code for '{desc}'. Include error handling and type hints where applicable. Follow PEP 8. Return only the code, no explanations. // Generated by DevDollz: Atelier Edition"
            
            try:
                # True async Ollama call - non-blocking
                response = await ollama.async_generate(model="mistral", prompt=prompt)
                result = response['response'].strip()
                meta = {"status": "success", "timestamp": time.time()}
                await output_queue.put(create_message(result, meta))
                log_to_db("code_gen", desc, result)
            except Exception as e:
                result = f"Error: Failed to generate code (Ollama unavailable): {str(e)}"
                meta = {"status": "error", "error": str(e)}
                await output_queue.put(create_message(result, meta))
                log_to_db("code_gen", desc, result)
                
        except asyncio.CancelledError:
            break
        finally:
            input_queue.task_done()

async def debug_agent(input_queue: asyncio.Queue, output_queue: asyncio.Queue):
    """Async debug agent with non-blocking Ollama calls and pylint integration"""
    while True:
        try:
            raw_task = await input_queue.get()
            if raw_task is None:  # Sentinel value to stop agent
                break
                
            task = parse_message(raw_task)
            cmd_type = task['meta'].get('type', '')
            code = task['content']
            
            if cmd_type == "pylint":
                # Run only pylint static analysis
                pylint_result = run_pylint(code)
                result = f"Static Analysis: {pylint_result}"
                meta = {"status": "success" if not pylint_result.startswith("Pylint error:") else "error", "timestamp": time.time()}
                await output_queue.put(create_message(result, meta))
                log_to_db("debug", code, result)
                
                # Learn from this action for precognition
                precognitive_ai.learn_from_action("debug", code, result)
                
            elif cmd_type in ["syntax", "logic"]:
                # Run only LLM analysis for specific types
                if cmd_type == "syntax":
                    prompt = f"Analyze this Python code for syntax errors: ```\n{code}\n```. Return only the analysis, no code or explanations. // DevDollz: Atelier Edition"
                else:
                    prompt = f"Analyze this Python code for logical errors and potential issues (e.g., edge cases, performance): ```\n{code}\n```. Return only the analysis, no code or explanations. // DevDollz: Atelier Edition"
                
                try:
                    llm_result = await ollama.async_generate(model="mistral", prompt=prompt)
                    result = llm_result['response'].strip()
                    meta = {"status": "success", "timestamp": time.time()}
                    await output_queue.put(create_message(result, meta))
                    log_to_db("debug", code, result)
                except Exception as e:
                    result = f"Error: Failed to analyze code (Ollama unavailable): {str(e)}"
                    meta = {"status": "error", "error": str(e)}
                    await output_queue.put(create_message(result, meta))
                    log_to_db("debug", code, result)
                    
            else:
                # Run both pylint and LLM for comprehensive debugging
                try:
                    # Run pylint first (synchronous, fast)
                    pylint_result = run_pylint(code)
                    
                    # Run LLM analysis (asynchronous)
                    llm_result = await ollama.async_generate(
                        model="mistral", 
                        prompt=f"Debug this Python code for any issues: ```\n{code}\n```. Return only the debug analysis, no code or explanations. // DevDollz: Atelier Edition"
                    )
                    
                    # Combine results
                    result = f"Static: {pylint_result} | AI: {llm_result['response'].strip()}"
                    meta = {"status": "success" if not (pylint_result.startswith("Pylint error:") or llm_result['response'].startswith("Error:")) else "error", "timestamp": time.time()}
                    await output_queue.put(create_message(result, meta))
                    log_to_db("debug", code, result)
                    
                except Exception as e:
                    result = f"Error: Failed to debug code: {str(e)}"
                    meta = {"status": "error", "error": str(e)}
                    await output_queue.put(create_message(result, meta))
                    log_to_db("debug", code, result)
                
        except asyncio.CancelledError:
            break
        finally:
            input_queue.task_done()

# Voice Recognition Agent - Remains in process for PyAudio compatibility
def voice_agent(input_queue, output_queue):
    try:
        import speech_recognition as sr
    except ImportError:
        output_queue.put(create_message("Dependencies missing. Run: pip install SpeechRecognition PyAudio", {"status": "error"}))
        return

    r = sr.Recognizer()
    while True:
        try:
            raw_task = input_queue.get(timeout=1)
            if raw_task == "STOP":
                break
            output_queue.put(create_message("Listening... // DevDollz: Atelier Edition", {"status": "info", "source": "voice"}))
            with sr.Microphone() as source:
                r.adjust_for_ambient_noise(source, duration=0.5)
                try:
                    audio = r.listen(source, timeout=5, phrase_time_limit=5)
                    text = r.recognize_google(audio)
                    output_queue.put(create_message(text, {"status": "success", "source": "voice"}))
                except sr.WaitTimeoutError:
                    output_queue.put(create_message("No audio detected within 5 seconds", {"status": "error", "source": "voice"}))
                except sr.UnknownValueError:
                    output_queue.put(create_message("Could not understand audio", {"status": "error", "source": "voice"}))
                except sr.RequestError as e:
                    output_queue.put(create_message(f"Speech service error: {e}", {"status": "error", "source": "voice"}))
        except queue.Empty:
            time.sleep(0.1)
        except Exception as e:
            output_queue.put(create_message(f"Voice agent error: {e}", {"status": "error", "source": "voice"}))

# ASYNC Orchestrator with proper asyncio integration
class Orchestrator:
    def __init__(self):
        # AI Agents now use asyncio.Queue for true async communication
        self.agent_queues = {
            "code_gen": (asyncio.Queue(), asyncio.Queue()),
            "debug": (asyncio.Queue(), asyncio.Queue()),
        }
        self.agent_tasks = []
        
        # Voice agent still uses multiprocessing for PyAudio compatibility
        self.voice_input = mp.Queue()
        self.voice_output = mp.Queue()
        self.voice_proc = mp.Process(target=voice_agent, args=(self.voice_input, self.voice_output), daemon=True)
        self.voice_proc.start()
        
        # Plugins will run in threads to avoid Windows pickling issues
        self.plugin_executor = ThreadPoolExecutor(max_workers=10)
        self.thread_agents = {}
        
        # Precognitive AI - Second Brain
        self.precog_ai = precognitive_ai
        self.precog_thread = threading.Thread(target=self._precog_monitor, daemon=True)
        self.precog_thread.start()

    async def start_agents(self):
        """Start core AI agents as asyncio tasks"""
        self.agent_tasks.append(asyncio.create_task(code_gen_agent(*self.agent_queues["code_gen"])))
        self.agent_tasks.append(asyncio.create_task(debug_agent(*self.agent_queues["debug"])))

    async def route_task(self, agent_name, cmd_type, task_content):
        """Route task to appropriate agent - async for AI agents, sync for plugins"""
        task_msg = create_message(task_content, {"type": cmd_type or "custom"})
        
        if agent_name in self.agent_queues:
            # Route to async AI agent
            await self.agent_queues[agent_name][0].put(task_msg)
            return True
        elif agent_name in self.thread_agents:
            # Route to thread-based plugin
            self.thread_agents[agent_name]["input_q"].put(task_msg)
            return True
        return False

    def load_plugin(self, file_path):
        """Load a plugin using ThreadPoolExecutor for Windows compatibility"""
        plugin_name = os.path.splitext(os.path.basename(file_path))[0]
        
        if plugin_name in self.agent_queues or plugin_name in self.thread_agents:
            return {"content": f"Agent or plugin '{plugin_name}' already loaded.", "meta": {"status": "error"}}

        try:
            # Security: Ensure path is within project root
            if not os.path.abspath(file_path).startswith(os.path.abspath(".")):
                return {"content": f"Access Denied: Plugins must be loaded from within the project directory.", "meta": {"status": "error"}}

            # Check if the plugin file exists and is readable
            if not os.path.exists(file_path):
                return {"content": f"Plugin file not found: {file_path}", "meta": {"status": "error"}}

            # Validate the plugin has the required interface
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if 'def plugin_agent(' not in content:
                        return {"content": f"Plugin must have a 'plugin_agent(input_queue, output_queue)' function.", "meta": {"status": "error"}}
            except Exception as e:
                return {"content": f"Failed to read plugin file: {e}", "meta": {"status": "error"}}

            # Load the plugin module
            spec = importlib.util.spec_from_file_location(plugin_name, file_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            if not hasattr(module, 'plugin_agent'):
                return {"content": "Plugin must have a 'plugin_agent' function.", "meta": {"status": "error"}}

            # Create thread-safe queues for the plugin
            input_q = queue.Queue()
            output_q = queue.Queue()
            
            # Submit the plugin to the thread pool
            future = self.plugin_executor.submit(module.plugin_agent, input_q, output_q)
            
            # Store the plugin agent data
            self.thread_agents[plugin_name] = {
                "input_q": input_q, 
                "output_q": output_q,
                "future": future,
                "type": "plugin"
            }
            
            # Log successful plugin loading
            log_to_db("system", f"plugin_load_{plugin_name}", f"Plugin loaded from {file_path}")
            
            return {"content": f"Plugin '{plugin_name}' loaded successfully. Use '{plugin_name} <task>' to route tasks.", "meta": {"status": "success"}}
            
        except Exception as e:
            error_msg = f"Failed to load plugin: {e}"
            log_to_db("system", f"plugin_load_{plugin_name}", error_msg)
            return {"content": error_msg, "meta": {"status": "error"}}
    
    def _precog_monitor(self):
        """Monitor user behavior and predict next actions"""
        while True:
            try:
                # Analyze patterns and auto-generate
                if self.precog_ai.precog_active:
                    # Auto-optimize any pending code
                    pass
                
                time.sleep(PRECOGNITION_CONFIG["precog_delay"])
            except Exception:
                time.sleep(1)
    
    async def get_results(self):
        """Collect results from all agents including plugins - async for AI agents"""
        results = []
        
        # Collect from async AI agents
        for source, (_, output_q) in self.agent_queues.items():
            while not output_q.empty():
                raw_res = output_q.get_nowait()
                res = parse_message(raw_res)
                res['meta']['source'] = source
                results.append(res)
        
        # Collect from thread agents (plugins)
        for agent_name, agent_data in self.thread_agents.items():
            q = agent_data["output_q"]
            try:
                while not q.empty():
                    raw_res = q.get_nowait()
                    res = parse_message(raw_res)
                    res['meta']['source'] = agent_name
                    results.append(res)
            except queue.Empty:
                pass
        
        # Voice agent (multiprocessing)
        try:
            while not self.voice_output.empty():
                raw_res = self.voice_output.get()
                res = parse_message(raw_res)
                res['meta']['source'] = "voice"
                results.append(res)
        except queue.Empty:
            pass
        
        return results

    def list_plugins(self):
        """List currently loaded plugins"""
        return list(self.thread_agents.keys())

    def start_voice_listening(self):
        """Activate voice listening"""
        self.voice_input.put("START")

    async def shutdown(self):
        """Clean shutdown of all agents"""
        # Stop async AI agents
        for input_q, _ in self.agent_queues.values():
            await input_q.put(None)  # Sentinel value to stop agents
        
        # Wait for async agents to finish
        if self.agent_tasks:
            await asyncio.gather(*self.agent_tasks, return_exceptions=True)
        
        # Stop thread agents (plugins)
        for agent_name, agent_data in self.thread_agents.items():
            agent_data["input_q"].put("STOP")
            # Wait for plugin to finish (with timeout)
            if agent_data["future"].running():
                agent_data["future"].cancel()
        
        # Shutdown thread pool
        self.plugin_executor.shutdown(wait=True)
        
        # Stop voice agent
        self.voice_input.put("STOP")
        self.voice_proc.terminate()

# DevDollz ASCII Logo
DEV_DOLLZ_LOGO = """
██████╗ ██╗██╗ ██╗██╗ ██╗ ██████╗ ██╗ ██╗ ███████╗
██╔══██╗██║██║ ██║██║ ██║██╔═══██╗██║ ██║ ╚══███╔╝
██║ ██║██║██║ ██║██║ ██║██║ ██║██║ ██║ ███╔╝
██║ ██║██║██║ ██║██║ ██║██║ ██║██║ ██║ ███╔╝
██████╔╝██║╚██████╔╝╚██████╔╝╚██████╔╝███████╗███████╗███████╗
╚═════╝ ╚═╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚══════╝╚══════╝
"""

# ASYNC Textual TUI App with proper asyncio integration
class SwarmIDEApp(App):
    BINDINGS = [
        Binding("ctrl+d", "debug_code", "Debug Code", show=True),
        Binding("ctrl+s", "save_file", "Save File", show=True),
        Binding("ctrl+v", "listen_voice", "Voice Command", show=True),
    ]

    CSS = """
    $background: #1A1A1B;
    $primary: #D944D4;
    $panel: #2C2C2E;
    $success: #D944D4;
    $error: #E06C75;
    $text: #EAEAEB;
    $muted: #8A8A8E;

    Screen {
        background: $background;
        color: $text;
    }

    /* === HEADER & FOOTER === */
    Header {
        display: none; /* Hide default header */
    }
    #logo {
        color: $muted;
        height: auto;
        padding: 1 0;
    }
    Footer {
        background: $background;
        color: $muted;
    }

    /* === PANELS & CONTAINERS === */
    Horizontal, Vertical {
        background: $background;
    }

    DirectoryTree, Log, TextArea {
        background: $panel;
        border: solid $panel;
        padding: 1 2;
    }

    Vertical {
        padding: 0;
        border: none;
    }

    /* === COMMAND INPUT === */
    Input {
        background: $background;
        border: solid $muted;
        padding: 0 1;
        color: $text;
        height: 1;
        margin-top: 1;
    }

    Input:focus {
        border: solid $primary;
    }

    Input > .input--placeholder {
        color: $muted;
        text-style: none;
    }

    /* === CODE EDITOR === */
    TextArea {
        background: $panel;
        border: solid $muted;
        color: $text;
    }

    TextArea:focus {
        border: solid $primary;
    }

    /* === FILE & DIRECTORY TREE === */
    DirectoryTree > .directory-tree--file {
        color: $text;
    }
    DirectoryTree > .directory-tree--folder {
        color: $text;
    }
    DirectoryTree > .directory-tree--selected {
        background: $primary;
        color: $background;
        text-style: bold;
    }

    /* === RESULTS LOG === */
    Log {
        color: $text;
        height: 10;
        margin-top: 1;
    }

    /* === SCROLLBARS === */
    ScrollBar {
        background: $panel;
        width: 1;
    }
    ScrollBar > .scrollbar-thumb {
        background: $muted;
    }
    """

    def __init__(self):
        super().__init__()
        self.orchestrator = None
        self.active_file_path = None
        self.project_root = os.path.abspath(".")

    def compose(self) -> ComposeResult:
        yield Static(DEV_DOLLZ_LOGO, id="logo")
        yield Horizontal(
            DirectoryTree(self.project_root, id="file-tree"),
            Vertical(
                TextArea(id="code-editor", language="python"),
                Log(id="results"),
                Input(placeholder="> Enter command...", id="command-input"),
                id="main-panel"
            )
        )
        yield Footer()

    async def on_mount(self) -> None:
        """Initialize orchestrator and start async agents"""
        self.orchestrator = Orchestrator()
        await self.orchestrator.start_agents()
        
        footer = self.query_one(Footer)
        footer.styles.content = "Built for power users - DevDollz: Atelier Edition"
        self.query_one("#command-input").focus()
        self.set_interval(0.1, self.check_results)
        text_log = self.query_one("#results", Log)
        text_log.write("Welcome to the Atelier. | DevDollz: Atelier Edition by Alexis Adams")
        text_log.write("🚀 Async Ollama integration enabled - Non-blocking AI calls")
        text_log.write("🔍 Pylint static analysis integration enabled")
        text_log.write("🧠 PRECOGNITIVE AI activated - Zero friction coding")
        text_log.write("⚡ Auto-optimization enabled - Vectorize loops, fix imports")
        text_log.write("🎯 Warp AI? We're already shipping while they're still typing")

    async def check_results(self) -> None:
        """Check for results from async agents"""
        if self.orchestrator:
            results = await self.orchestrator.get_results()
            text_log = self.query_one("#results", Log)
            for res in results:
                status = res['meta'].get('status', 'unknown')
                source = res['meta'].get('source', 'ai')
                
                if source == 'voice':
                    if status == 'success':
                        text_log.write(f"[»] Recognized: \"{res['content']}\"")
                        await self.process_command(res['content'])
                    elif status == 'info':
                        text_log.write(f"[»] {res['content']}")
                    else:
                        text_log.write(f"[x] {res['content']}")
                else:
                    if status == "success":
                        text_log.write(f"[◆] [{source}] {res['content']}")
                    else:
                        text_log.write(f"[x] [{source}] {res['content']}")

    def on_input_submitted(self, event: Input.Submitted) -> None:
        """Handle command input submission"""
        asyncio.create_task(self.process_command(event.value))
        event.input.value = ""

    async def process_command(self, command: str) -> None:
        """Process commands asynchronously with precognitive AI"""
        text_log = self.query_one("#results", Log)
        command = command.strip()
        
        # Precognitive AI: Auto-generate before you finish thinking
        if len(command) > 3 and command not in ['help', 'quit', 'exit']:
            # Check if precog AI can predict what you want
            auto_result = precognitive_ai.auto_generate_code(command)
            if auto_result:
                text_log.write(f"[🧠] Precognition: {auto_result[:100]}...")
                # Auto-optimize the result
                optimized = precognitive_ai.auto_optimize_code(auto_result)
                if optimized != auto_result:
                    text_log.write(f"[⚡] Auto-optimized: {optimized[:100]}...")
        
        protocol_text = "Atelier Protocol:\n  generate [function|class|code] <desc>\n  debug [syntax|logic|code|pylint] <desc>\n  history [limit]\n  plugin load <path>\n  <plugin_name> <task>\n  Ctrl+V: Voice Command"

        if command.lower() in ['quit', 'exit']:
            self.exit()
            return
        if command.lower() == 'help':
            text_log.write(protocol_text)
            return
        
        if command.startswith("history"):
            self.action_show_history(command)
            return

        if command.startswith("plugin load"):
            parts = command.split(maxsplit=2)
            if len(parts) < 3:
                text_log.write("[x] Usage: plugin load <path_to_file.py>")
                return
            
            file_path = parts[2]
            if not os.path.abspath(file_path).startswith(self.project_root):
                text_log.write(f"[x] Access Denied: Plugins must be loaded from within the project directory.")
                return

            result = self.orchestrator.load_plugin(file_path)
            status = result['meta'].get('status', 'unknown')
            if status == "success":
                text_log.write(f"[◆] {result['content']}")
            else:
                text_log.write(f"[x] {result['content']}")
            return

        # Normalize spoken commands
        command = (command.replace("create function", "generate function")
                          .replace("create class", "generate class")
                          .replace("create code", "generate code")
                          .replace("check syntax", "debug syntax")
                          .replace("check logic", "debug logic")
                          .replace("check pylint", "debug pylint"))

        parts = command.split(maxsplit=2)
        if len(parts) < 1:
            text_log.write(f"Access Denied. Please verify command syntax.\n{protocol_text}")
            return

        agent_name = parts[0]
        if len(parts) == 1:
            task_content = ""
        else:
            cmd_type = parts[1]
            task_content = parts[2] if len(parts) > 2 else ""

        if agent_name in self.orchestrator.thread_agents:
            text_log.write(f"[»] Routing to plugin '{agent_name}'...")
            self.orchestrator.route_task(agent_name, cmd_type, task_content)
            return

        if agent_name not in ["generate", "debug"]:
            text_log.write(f"Access Denied. Unknown command or plugin.\n{protocol_text}")
            return

        agent_name = "code_gen" if agent_name == "generate" else "debug"
        text_log.write("[»] Crafting response with async Ollama...")
        await self.orchestrator.route_task(agent_name, cmd_type, task_content)

    def on_directory_tree_file_selected(self, event: DirectoryTree.FileSelected) -> None:
        text_log = self.query_one("#results", Log)
        code_editor = self.query_one("#code-editor", TextArea)
        
        file_path = event.path
        if not os.path.abspath(file_path).startswith(self.project_root):
            text_log.write(f"[x] Access Denied: Cannot access files outside the project directory.")
            return

        try:
            with open(file_path, "r") as file:
                code_editor.text = file.read()
            self.active_file_path = file_path
            text_log.write(f"[»] Loaded file: {os.path.basename(file_path)}")
        except Exception as e:
            text_log.write(f"[x] Error loading file: {e}")
            self.active_file_path = None

    def action_debug_code(self) -> None:
        """Debug the code currently in the editor (Ctrl+D)"""
        asyncio.create_task(self._debug_code_async())

    async def _debug_code_async(self) -> None:
        """Async debug code implementation"""
        code_editor = self.query_one("#code-editor", TextArea)
        text_log = self.query_one("#results", Log)
        code = code_editor.text.strip()
        if not code:
            text_log.write("[x] No code in editor to debug.")
            return
        
        cmd_type = "code"  # Runs both pylint and LLM
        text_log.write("[»] Debugging code from editor with pylint + async Ollama...")
        await self.orchestrator.route_task("debug", cmd_type, code)

    def action_save_file(self) -> None:
        text_log = self.query_one("#results", Log)
        if self.active_file_path is None:
            text_log.write("[x] No active file selected. Load a file first.")
            return

        if not os.path.abspath(self.active_file_path).startswith(self.project_root):
            text_log.write(f"[x] Access Denied: Cannot save files outside the project directory.")
            return

        code_editor = self.query_one("#code-editor", TextArea)
        try:
            with open(self.active_file_path, "w") as file:
                file.write(code_editor.text)
            text_log.write(f"[◆] Saved file: {os.path.basename(self.active_file_path)}")
        except Exception as e:
            text_log.write(f"[x] Error saving file: {e}")

    def action_show_history(self, command: str) -> None:
        text_log = self.query_one("#results", Log)
        parts = command.split()
        limit = 10
        if len(parts) > 1 and parts[1].isdigit():
            limit = int(parts[1])
        
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("SELECT timestamp, agent, task FROM history ORDER BY id DESC LIMIT ?", (limit,))
            records = cursor.fetchall()
            conn.close()

            if not records:
                text_log.write("[»] No history found.")
                return
            
            history_text = "[»] Command History:\n"
            for rec in records:
                ts, agent, task = rec
                short_task = (task[:40] + '...') if len(task) > 40 else task
                history_text += f"  - {ts[:19]} [{agent}]: {short_task}\n"
            text_log.write(history_text)
        except Exception as e:
            text_log.write(f"[x] Error fetching history: {e}")

    def action_listen_voice(self) -> None:
        """Activate voice listening (Ctrl+V)"""
        if self.orchestrator:
            self.orchestrator.start_voice_listening()

    def on_key(self, event):
        if event.key == "question_mark":
            text_log = self.query_one("#results", Log)
            text_log.write("Atelier Protocol:\n  generate [function|class|code] <desc>\n  debug [syntax|logic|code|pylint] <desc>\n  history [limit]\n  plugin load <path>\n  <plugin_name> <task>\n  Ctrl+V: Voice Command")
            text_log.write("\n🚀 Async Features:")
            text_log.write("  - Non-blocking Ollama calls")
            text_log.write("  - Responsive TUI during AI operations")
            text_log.write("  - True concurrent agent processing")
            text_log.write("\n🔍 Pylint Features:")
            text_log.write("  - Static code analysis")
            text_log.write("  - PEP 8 compliance")
            text_log.write("  - Combined with AI analysis")
            text_log.write("\n🧠 PRECOGNITIVE AI:")
            text_log.write("  - Zero friction code generation")
            text_log.write("  - Auto-optimization (vectorize loops, fix imports)")
            text_log.write("  - Learn your preferences automatically")
            text_log.write("  - Ship before you finish thinking")
            text_log.write("\n⚡ Performance:")
            text_log.write("  - 100ms precognition delay")
            text_log.write("  - Auto-vectorization for 5x speed")
            text_log.write("  - Smart import management")
        elif event.key == "tab":
            self.screen.focus_next()

    async def on_unmount(self) -> None:
        """Clean shutdown of async orchestrator"""
        if self.orchestrator:
            await self.orchestrator.shutdown()

# CLI Fallback with async support
async def cli_main():
    """Async CLI fallback for when Textual is unavailable"""
    print("DevDollz: Atelier Edition - CLI Fallback Mode")
    print("Built for power users - DevDollz: Atelier Edition")
    print("🚀 Async Ollama integration enabled")
    print("🔍 Pylint static analysis enabled")
    print("=" * 60)
    
    orch = Orchestrator()
    await orch.start_agents()
    
    print("DevDollz: Atelier Edition - Orchestrator initialized")
    print("Type 'help' for available commands")
    print("")
    
    try:
        while True:
            try:
                command = input("DevDollz> ").strip()
                if not command:
                    continue
                
                if command.lower() in ['quit', 'exit']:
                    print("DevDollz: Atelier Edition - Shutting down...")
                    break
                
                if command.lower() == 'help':
                    print("DevDollz: Atelier Edition - Available Commands:")
                    print("  generate [function|class|code] <description>")
                    print("  debug [syntax|logic|code|pylint] <description>")
                    print("  history [limit]")
                    print("  plugin load <path>")
                    print("  plugins")
                    print("  help")
                    print("  quit")
                    print("\n🚀 Async Features:")
                    print("  - Non-blocking Ollama calls")
                    print("  - Concurrent agent processing")
                    print("\n🔍 Pylint Features:")
                    print("  - Static code analysis")
                    print("  - PEP 8 compliance")
                    continue
                
                # Process command asynchronously
                if command.startswith("generate") or command.startswith("debug"):
                    parts = command.split(maxsplit=2)
                    if len(parts) < 2:
                        print("Usage: generate/debug <type> <description>")
                        continue
                    
                    cmd_type = parts[0]
                    sub_type = parts[1] if len(parts) > 1 else "code"
                    task_content = parts[2] if len(parts) > 2 else ""
                    
                    agent_name = "code_gen" if cmd_type == "generate" else "debug"
                    print(f"[»] Processing with async Ollama...")
                    await orch.route_task(agent_name, sub_type, task_content)
                    
                    # Wait for results
                    await asyncio.sleep(0.5)
                    results = await orch.get_results()
                    
                    if results:
                        for res in results:
                            status = res['meta'].get('status', 'unknown')
                            source = res['meta'].get('source', 'ai')
                            if status == "success":
                                print(f"[◆] [{source}] {res['content']}")
                            else:
                                print(f"[x] [{source}] {res['content']}")
                    else:
                        print("No results received.")
                else:
                    print(f"Unknown command: {command}")
                    print("Use 'help' for available commands.")
                    
            except KeyboardInterrupt:
                print("\nDevDollz: Atelier Edition - Use 'quit' to exit.")
            except Exception as e:
                print(f"DevDollz: Atelier Edition - Error: {e}")
                
    finally:
        await orch.shutdown()
        print("DevDollz: Atelier Edition - Shutdown complete.")
        print("Brand: DevDollz: Atelier Edition - Built for power users")

# Main entry point
if __name__ == "__main__":
    try:
        SwarmIDEApp().run()
    except Exception as e:
        print(f"TUI failed to load ({e}). Falling back to async CLI.")
        asyncio.run(cli_main())
